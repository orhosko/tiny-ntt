#!/usr/bin/env python3
"""
Generate inverse twiddle factors for N=256 NWC NTT
ψ^(-k) mod q for k = 0, 1, 2, ..., 255

For inverse NTT, we need the inverse of the primitive root:
ψ = 1239911 (primitive 512th root of unity mod 8380417)
ψ^(-1) = modinv(ψ, 8380417)

Then compute: ψ^(-k) = (ψ^(-1))^k mod q
"""

def mod_exp(base, exp, mod):
    """Modular exponentiation: base^exp mod mod"""
    result = 1
    base = base % mod
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        exp = exp >> 1
        base = (base * base) % mod
    return result

def mod_inv(a, mod):
    """Modular inverse using extended Euclidean algorithm"""
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y
    
    gcd, x, _ = extended_gcd(a % mod, mod)
    if gcd != 1:
        raise ValueError(f"{a} has no inverse mod {mod}")
    return (x % mod + mod) % mod

def generate_inverse_twiddles(N=256, q=8380417, psi=1239911):
    """
    Generate all inverse twiddle factors for inverse NTT
    
    Args:
        N: NTT size (must be power of 2)
        q: Modulus (prime)
        psi: Primitive 2N-th root of unity mod q
    
    Returns:
        List of N inverse twiddle factors
    """
    # Compute ψ^(-1)
    psi_inv = mod_inv(psi, q)
    
    print(f"Generating inverse twiddle factors for N={N}, q={q}")
    print(f"ψ = {psi}")
    print(f"ψ^(-1) = {psi_inv}")
    print()
    
    # Verify ψ × ψ^(-1) ≡ 1 (mod q)
    check = (psi * psi_inv) % q
    assert check == 1, f"Inverse check failed: {psi} × {psi_inv} = {check} (mod {q})"
    print(f"✓ Verified: {psi} × {psi_inv} ≡ 1 (mod {q})")
    print()
    
    # Generate all inverse twiddle factors
    inverse_twiddles = []
    for k in range(N):
        twiddle = mod_exp(psi_inv, k, q)
        inverse_twiddles.append(twiddle)
    
    return inverse_twiddles

def generate_verilog_rom(twiddles, filename="inverse_twiddle_rom.sv"):
    """Generate SystemVerilog ROM module"""
    
    with open(filename, 'w') as f:
        f.write("""`timescale 1ns / 1ps

//==============================================================================
// Inverse Twiddle Factor ROM for Inverse NTT
//==============================================================================
// Contains precomputed inverse twiddle factors: ψ^(-k) mod q
// where ψ^(-1) is the inverse of ψ mod q
//
// Generated by: scripts/generate_inverse_twiddles.py
//==============================================================================

module inverse_twiddle_rom #(
    parameter int WIDTH = 32,      // Bit width
    parameter int ADDR_WIDTH = 8  // Address width
) (
    input  logic [ADDR_WIDTH-1:0] addr,    // Read address
    output logic [WIDTH-1:0]      twiddle  // Inverse twiddle factor output
);

    // Inverse twiddle factor lookup table
    always_comb begin
        case (addr)
""")
        
        # Write all twiddle factors
        for i, twiddle in enumerate(twiddles):
            f.write(f"            8'd{i}: twiddle = 32'd{twiddle};\n")
        
        f.write("""            default: twiddle = 32'd0;
        endcase
    end

endmodule
""")
    
    print(f"✓ Generated SystemVerilog ROM: {filename}")

if __name__ == "__main__":
    # Parameters
    N = 256
    q = 8380417
    psi = 1239911
    
    # Generate inverse twiddles
    inverse_twiddles = generate_inverse_twiddles(N, q, psi)
    
    # Print first few for verification
    print("First 10 inverse twiddle factors:")
    for i in range(10):
        print(f"  ψ^(-{i}) = {inverse_twiddles[i]}")
    print()
    
    # Verify some properties
    print("Verification:")
    # ψ^0 = 1
    assert inverse_twiddles[0] == 1, "ψ^(-0) should be 1"
    print(f"  ψ^(-0) = {inverse_twiddles[0]} ✓")
    
    # ψ^(-1)
    psi_inv = mod_inv(psi, q)
    assert inverse_twiddles[1] == psi_inv, "ψ^(-1) should match inverse"
    print(f"  ψ^(-1) = {inverse_twiddles[1]} ✓")
    
    # ψ^(-N) should be -1 (negacyclic property)
    psi_neg_n = mod_exp(psi_inv, N, q)
    assert psi_neg_n == q - 1, "ψ^(-N) should be -1"
    print(f"  ψ^(-{N}) = {psi_neg_n} ✓")
    print()
    
    # Generate Verilog ROM
    output_file = "../rtl/inverse_twiddle_rom.sv"
    generate_verilog_rom(inverse_twiddles, output_file)
    print()
    print("=" * 60)
    print("Inverse twiddle generation complete!")
    print("=" * 60)
